@page "/tasks"
@layout MainLayout

@using CRM.Client.DTOs.Tasks
@using CRM.Client.DTOs.Shared
@using CRM.Client.Services.Tasks
@using CRM.Client.Services.Users
@using CRM.Client.Services.Customers
@using CRM.Client.Components.Modals.TaskModals
@using CRM.Client.Components.Shared
@using CRM.Client.Components.Layout

@inject TaskService TaskService
@inject UserService UserService
@inject CustomerService CustomerService

<h3>Tasks</h3>

<div class="mb-3 d-flex gap-2 align-items-center">
    <button type="button" class="btn btn-primary" @onclick="OpenCreate">+ New Task</button>

    <!-- Search (uses paged endpoint with search param) -->
    <input class="form-control ms-3" style="max-width:320px"
           placeholder="Search title / description / priority..."
           value="@SearchText"
           @oninput="OnSearchChanged" />

    <!-- PageSize selector -->
    <select class="form-select w-auto ms-3" @bind="PageSize">
        <option value="5">5</option>
        <option value="10">10</option>
        <option value="20">20</option>
        <option value="50">50</option>
    </select>
</div>

@if (IsLoading)
{
    <p>Loading tasks...</p>
}
else if (Tasks == null || !Tasks.Any())
{
    <p>No tasks found.</p>
}
else
{
    <table class="table table-bordered align-middle">
        <thead class="table-light">
            <tr>
                <th>Title</th>
                <th>Customer</th>
                <th>User</th>

                <th @onclick='() => SortByColumn("dueDate")' style="cursor:pointer">
                    Due Date
                    @if (SortBy == "dueDate")
                    {
                        <span> (@(SortDir == "desc" ? "↓" : "↑"))</span>
                    }
                </th>

                <th>Priority</th>

                <th @onclick='() => SortByColumn("createdAt")' style="cursor:pointer">
                    Created
                    @if (SortBy == "createdAt")
                    {
                        <span> (@(SortDir == "desc" ? "↓" : "↑"))</span>
                    }
                </th>

                <th>Status</th>
                <th>Recurring</th>
                <th style="width:220px">Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var task in Tasks)
            {
                <tr>
                    <td>@task.Title</td>
                    <td>@GetCustomerName(task.CustomerId)</td>
                    <td>@GetUserName(task.UserId)</td>
                    <td>@task.DueDate.ToString("dd MMM yyyy")</td>
                    <td>@task.Priority</td>
                    <td>@task.CreatedAt.ToLocalTime().ToString("dd MMM yyyy hh:mm tt")</td>
                    <td>@task.State</td>
                    <td>
                        @if (task.IsRecurring)
                        {
                            <span class="badge bg-info">@task.RecurrenceType (@task.RecurrenceInterval)</span>
                        }
                        else
                        {
                            <span class="badge bg-secondary">No</span>
                        }
                    </td>
                    <td>
                        <button class="btn btn-light btn-sm me-2" @onclick="() => OpenEdit(task)">Edit</button>
                        <button class="btn btn-danger btn-sm" @onclick="() => OpenDelete(task.TaskId)">Delete</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>

    <Pager CurrentPage="@CurrentPage"
           PageSize="@PageSize"
           TotalCount="@TotalCount"
           OnPageChanged="OnPageChanged" />
}

<CreateTaskModal IsOpen="@IsCreateOpen" OnClose="HandleCreateClosed" />
<EditTaskModal IsOpen="@IsEditOpen" Task="@SelectedTask" OnClose="HandleEditClosed" />
<DeleteTaskModal IsOpen="@IsDeleteOpen" TaskId="@SelectedTaskId" OnClose="HandleDeleteClosed" />

@code {
    // data
    private List<TaskResponseDto> Tasks = new();
    private TaskResponseDto? SelectedTask;
    private Guid? SelectedTaskId;

    // modals
    private bool IsCreateOpen;
    private bool IsEditOpen;
    private bool IsDeleteOpen;

    // lookup caches
    private readonly Dictionary<Guid, string> _customerNames = new();
    private readonly Dictionary<string, string> _userNames = new(StringComparer.OrdinalIgnoreCase);

    // pagination, search, sort
    private int CurrentPage = 1;
    private int _pageSize = 20;
    private long TotalCount = 0;
    private bool IsLoading = true;
    private bool _clamping = false;

    private string? SearchText;
    private string? SortBy;
    private string? SortDir; // "asc" or "desc"

    private int PageSize
    {
        get => _pageSize;
        set
        {
            if (_pageSize == value) return;
            _pageSize = value;
            CurrentPage = 1;
            _ = InvokeAsync(async () => { await LoadPage(); StateHasChanged(); });
        }
    }

    // ensure we call after prerender so JS interop is allowed
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadLookups();
            await LoadPage();
            StateHasChanged();
        }
    }

    private async Task LoadLookups()
    {
        // load customers (best-effort; swallow errors)
        try
        {
            var customers = await CustomerService.GetAllAsync();
            if (customers != null)
            {
                _customerNames.Clear();
                foreach (var c in customers)
                {
                    var name = string.IsNullOrWhiteSpace(c.PreferredName) ? $"{c.FirstName} {c.SurName}".Trim() : c.PreferredName;
                    _customerNames[c.CustomerId] = name;
                }
            }
        }
        catch
        {
            _customerNames.Clear();
        }

        // load users (best-effort)
        try
        {
            var users = await UserService.GetAllUsersAsync();
            if (users != null)
            {
                _userNames.Clear();
                foreach (var u in users)
                {
                    var display = string.IsNullOrWhiteSpace(u.FullName) ? u.Email : $"{u.FullName} ({u.Email})";
                    _userNames[u.Id] = display;
                }
            }
        }
        catch
        {
            _userNames.Clear();
        }
    }

    private async Task LoadPage()
    {
        IsLoading = true;
        StateHasChanged();

        var paged = await TaskService.GetPagedAsync(CurrentPage, PageSize, SearchText, SortBy, SortDir);

        if (paged == null)
        {
            Tasks = new();
            TotalCount = 0;
            IsLoading = false;
            return;
        }

        // clamp if page > total
        if (!_clamping && paged.TotalPages > 0 && CurrentPage > paged.TotalPages)
        {
            _clamping = true;
            CurrentPage = paged.TotalPages;
            await LoadPage();
            _clamping = false;
            return;
        }

        Tasks = paged.Items;
        TotalCount = paged.TotalCount;
        CurrentPage = paged.Page;
        _pageSize = paged.PageSize;

        IsLoading = false;
    }

    private async Task OnPageChanged(int page)
    {
        CurrentPage = page;
        await LoadPage();
    }

    private async Task OnSearchChanged(ChangeEventArgs e)
    {
        SearchText = e.Value?.ToString();
        CurrentPage = 1;
        await LoadPage();
    }

    private void SortByColumn(string col)
    {
        if (SortBy == col)
        {
            SortDir = (SortDir == "desc") ? "asc" : "desc";
        }
        else
        {
            SortBy = col;
            SortDir = "asc";
        }

        CurrentPage = 1;
        _ = InvokeAsync(async () => { await LoadPage(); StateHasChanged(); });
    }

    // --- GET NAME HELPERS (lazy fetch if missing) ---
    private string GetCustomerName(Guid customerId)
    {
        if (customerId == Guid.Empty) return "-";

        if (_customerNames.TryGetValue(customerId, out var name))
            return name;

        // fire-and-forget fetch
        _ = FetchCustomerNameAsync(customerId);
        return customerId.ToString(); // temporary placeholder while fetching
    }

    private async Task FetchCustomerNameAsync(Guid id)
    {
        if (_customerNames.ContainsKey(id)) return;

        try
        {
            var c = await CustomerService.GetByIdAsync(id);
            string display;

            if (c == null)
                display = "-";
            else
                display = string.IsNullOrWhiteSpace(c.PreferredName) ? $"{c.FirstName} {c.SurName}".Trim() : c.PreferredName;

            _customerNames[id] = display;
        }
        catch
        {
            _customerNames[id] = "-";
        }

        await InvokeAsync(StateHasChanged);
    }

    private string GetUserName(string? userId)
    {
        if (string.IsNullOrWhiteSpace(userId)) return "-";

        if (_userNames.TryGetValue(userId, out var name))
            return name;

        _ = FetchUserNameAsync(userId);
        return userId; // temporary placeholder
    }

    private async Task FetchUserNameAsync(string userId)
    {
        if (string.IsNullOrWhiteSpace(userId) || _userNames.ContainsKey(userId)) return;

        try
        {
            var u = await UserService.GetUserByIdAsync(userId);
            string display;

            if (u == null)
                display = "-";
            else
                display = string.IsNullOrWhiteSpace(u.FullName) ? u.Email : $"{u.FullName} ({u.Email})";

            _userNames[userId] = display;
        }
        catch
        {
            _userNames[userId] = "-";
        }

        await InvokeAsync(StateHasChanged);
    }

    // --- modals & actions ---
    private void OpenCreate() => IsCreateOpen = true;

    private void OpenEdit(TaskResponseDto task)
    {
        SelectedTask = task;
        IsEditOpen = true;
    }

    private void OpenDelete(Guid taskId)
    {
        SelectedTaskId = taskId;
        IsDeleteOpen = true;
    }

    private async Task HandleCreateClosed(bool refresh)
    {
        IsCreateOpen = false;
        if (refresh) await LoadPage();
    }

    private async Task HandleEditClosed(bool refresh)
    {
        IsEditOpen = false;
        SelectedTask = null;
        if (refresh) await LoadPage();
    }

    private async Task HandleDeleteClosed(bool refresh)
    {
        IsDeleteOpen = false;
        SelectedTaskId = null;
        if (refresh) await LoadPage();
    }
}
